
import { assert, assMatch } from '../utils/assert';
import { is } from '../utils/miscutils';
import DataClass from './DataClass';
import XId from './XId';

const DEFAULT_CONSENT = "dflt";

/** impact utils */
class Claim extends DataClass {
	/**
	 * @type {!String}
	 */
	k;
	v;
	/** @type {TimeString} */
	t = new Date().toISOString();
	/** @type {XId[]} */
	f;
	/** @type {String[]} */
	c;
	/** @type {Number} */
	w;

	/** Puts data into the "Claim" format that Profiler can understand 
	 *  NB: if Claim is generated by user input (entering a value in to PropControl field)
	 *  then 'from' should contain 'myloop@app'
	 * @param {Object} p
	 * @param {!String} p.key
	 * @param {!String|Number|Boolean} p.value
	 * @param {!XId|XId[]} p.from
	 * @param {String[]|boolean} c - e.g. ['public']
	 * @param {String[]|boolean} consent - Same as c!
	 * 
	*/
	constructor({key, value, from, c, consent}) {
		super(); // no base passed into super 'cos its handled below
		assMatch(value, "String|Number|Boolean"); // Only primitive values allowed
		// convert a single XId to an array?
		if ( ! Array.isArray(from)) from = [from];
		// Converting from internally held true/false to something
		// That the back-end can understand
		if ( ! is(c)) c = consent;
		if ( ! is(c)) c = [DEFAULT_CONSENT];
		if ( typeof c === 'boolean' ) c = c ? ['public'] : ['private']

		let base = {
			c,
			v: value,
			f: from,
			k: key
		};
		Object.assign(this, base);
		assMatch(from, 'String[]');
		assMatch(key, String); 
		// NB: kv, o are backend fields made by the backend for internal (ES) use
	};
} // ./Claim
DataClass.register(Claim, "Claim");
export default Claim;


/**
 * ??dubious use cases
 */
Claim.getClaims = person => {
	if ( ! person ) return {};
	Person.assIsa(person, "Profiler.js getClaims");
	const claims = person.claims;
	return claims || {};
};

/**
 * Two claims "overlap" if they have the same key and source. The values do NOT have to be the same!
 * The older overlapping claim should be removed
 */
Claim.overlap = (claimA, claimB) => {
	if (claimA.k !== claimB.k) return false;
	let af = (claimA.f || []).join("+");
	let bf = (claimB.f || []).join("+");
	return af === bf;
};
