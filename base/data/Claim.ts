
// import {assert, assMatch} from 'sjtest';
// import {asNum} from 'wwutils';
import DataClass, { TimeString, XIdString } from './DataClass';
import C from '../CBase';
import Person from './Person';

// interface
interface ClaimData {
	key: string,
	value: any,
	from: string | string[],
	c?: string[] | boolean,
	consent?: string[] | boolean
}

/** impact utils */
class Claim extends DataClass {
	k!: string;
	v: any;
	t: TimeString = new Date().toISOString();
	f: XIdString[] = [];
	c: string[] = [];
	static to: any;
	static getClaims: (person: any) => any;

	/** Puts data into the "Claim" format that Profiler can understand 
	 *  NB: if Claim is generated by user input (entering a value in to PropControl field)
	 * 	then 'from' should contain 'myloop@app' 
	 * @param {String} key
	 * @param {String[]|boolean} c - e.g. ['public']
	 * @param {String[]|boolean} consent - Same as c!
	 * 
	*/
	
	// NOTE: TS compiler will yell at us here because of the ungodly Object.assign use at the bottom.
	// DataClass should be redesigned eventually to address it, but for now it is safe to ignore. Babel is more tolerant.
	constructor({key, value, from, c, consent}: ClaimData) {
		super(); // no base passed into super 'cos its handled below
		// convert a single XId to an array?
		if (typeof from === 'string') from = [from];	
		// Converting from internally held true/false to something
		// That the back-end can understand
		if ( typeof c === 'boolean' ) c = c ? ['public'] : ['private']

		let base = {
			c: c || consent,
			v: value,
			f: from,
			k: key
		};
		Object.assign(this, base);; 
		// NB: kv, o are backend fields made by the backend for internal (ES) use
	};
} // ./Claim

DataClass.register(Claim, "Claim");
const This = Claim;
export default Claim;


/**
 * ??dubious use cases
 */
Claim.getClaims = person => {
	if ( ! person ) return {};
	Person.assIsa(person, "Profiler.js getClaims");
	const claims = person.claims;
	return claims || {};
};

