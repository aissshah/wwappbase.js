'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

/**
 * 
 * @param {*} valueOrPromise 
 * @returns {value: ?Object, promise: !Promise, error: ?Object, resolved: boolean} 
 *  The return is never null, and the promise part is always set.
 * 	The behaviour depends on valueOrPromise:
 * 	If it's a value -> resolved Promise
 * * 	If it's a Promise (or thenable) -> the input Promise
 * 	null/undefined -> rejected Promise
 */
function pv(valueOrPromise) {
	if (valueOrPromise === null || valueOrPromise === undefined) {
		var err = new Error("null value");
		return {
			error: err,
			promise: Promise.reject(err),
			resolved: true
		};
	}
	// NB: Promise.resolve() can be used with Promises without nesting	
	if (typeof valueOrPromise.then === 'function') {
		// Having then() is the only real requirement for a Promise
		var vp = { promise: valueOrPromise };
		// set the value when we have it
		valueOrPromise.then(function (r) {
			vp.value = r;
			vp.resolved = true;
			return r;
		});
		// also store any error
		if (typeof valueOrPromise.fail === 'function') {
			valueOrPromise.fail(function (err) {
				vp.error = err;
				vp.resolved = true;
				return err;
			});
		}
		return vp;
	}
	// It's a value - return now
	return {
		value: valueOrPromise,
		resolved: true,
		promise: Promise.resolve(valueOrPromise)
	};
};

exports.default = pv;